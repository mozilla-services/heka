// Code generated by protoc-gen-gogo.
// source: message.proto
// DO NOT EDIT!

/*
	Package message is a generated protocol buffer package.

	It is generated from these files:
		message.proto

	It has these top-level messages:
		Header
		Field
		Message
*/
package message

import proto "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "gogo.pb"

import math1 "math"

import io "io"
import math2 "math"
import fmt "fmt"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Header_HmacHashFunction int32

const (
	Header_MD5  Header_HmacHashFunction = 0
	Header_SHA1 Header_HmacHashFunction = 1
)

var Header_HmacHashFunction_name = map[int32]string{
	0: "MD5",
	1: "SHA1",
}
var Header_HmacHashFunction_value = map[string]int32{
	"MD5":  0,
	"SHA1": 1,
}

func (x Header_HmacHashFunction) Enum() *Header_HmacHashFunction {
	p := new(Header_HmacHashFunction)
	*p = x
	return p
}
func (x Header_HmacHashFunction) String() string {
	return proto.EnumName(Header_HmacHashFunction_name, int32(x))
}
func (x *Header_HmacHashFunction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Header_HmacHashFunction_value, data, "Header_HmacHashFunction")
	if err != nil {
		return err
	}
	*x = Header_HmacHashFunction(value)
	return nil
}

type Field_ValueType int32

const (
	Field_STRING  Field_ValueType = 0
	Field_BYTES   Field_ValueType = 1
	Field_INTEGER Field_ValueType = 2
	Field_DOUBLE  Field_ValueType = 3
	Field_BOOL    Field_ValueType = 4
)

var Field_ValueType_name = map[int32]string{
	0: "STRING",
	1: "BYTES",
	2: "INTEGER",
	3: "DOUBLE",
	4: "BOOL",
}
var Field_ValueType_value = map[string]int32{
	"STRING":  0,
	"BYTES":   1,
	"INTEGER": 2,
	"DOUBLE":  3,
	"BOOL":    4,
}

func (x Field_ValueType) Enum() *Field_ValueType {
	p := new(Field_ValueType)
	*p = x
	return p
}
func (x Field_ValueType) String() string {
	return proto.EnumName(Field_ValueType_name, int32(x))
}
func (x *Field_ValueType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Field_ValueType_value, data, "Field_ValueType")
	if err != nil {
		return err
	}
	*x = Field_ValueType(value)
	return nil
}

type Header struct {
	MessageLength    *uint32                  `protobuf:"varint,1,req,name=message_length" json:"message_length,omitempty"`
	HmacHashFunction *Header_HmacHashFunction `protobuf:"varint,3,opt,name=hmac_hash_function,enum=message.Header_HmacHashFunction,def=0" json:"hmac_hash_function,omitempty"`
	HmacSigner       *string                  `protobuf:"bytes,4,opt,name=hmac_signer" json:"hmac_signer,omitempty"`
	HmacKeyVersion   *uint32                  `protobuf:"varint,5,opt,name=hmac_key_version" json:"hmac_key_version,omitempty"`
	Hmac             []byte                   `protobuf:"bytes,6,opt,name=hmac" json:"hmac,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}

const Default_Header_HmacHashFunction Header_HmacHashFunction = Header_MD5

func (m *Header) GetMessageLength() uint32 {
	if m != nil && m.MessageLength != nil {
		return *m.MessageLength
	}
	return 0
}

func (m *Header) GetHmacHashFunction() Header_HmacHashFunction {
	if m != nil && m.HmacHashFunction != nil {
		return *m.HmacHashFunction
	}
	return Default_Header_HmacHashFunction
}

func (m *Header) GetHmacSigner() string {
	if m != nil && m.HmacSigner != nil {
		return *m.HmacSigner
	}
	return ""
}

func (m *Header) GetHmacKeyVersion() uint32 {
	if m != nil && m.HmacKeyVersion != nil {
		return *m.HmacKeyVersion
	}
	return 0
}

func (m *Header) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

type Field struct {
	Name             *string          `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	ValueType        *Field_ValueType `protobuf:"varint,2,opt,name=value_type,enum=message.Field_ValueType,def=0" json:"value_type,omitempty"`
	Representation   *string          `protobuf:"bytes,3,opt,name=representation" json:"representation,omitempty"`
	ValueString      []string         `protobuf:"bytes,4,rep,name=value_string" json:"value_string,omitempty"`
	ValueBytes       [][]byte         `protobuf:"bytes,5,rep,name=value_bytes" json:"value_bytes,omitempty"`
	ValueInteger     []int64          `protobuf:"varint,6,rep,packed,name=value_integer" json:"value_integer,omitempty"`
	ValueDouble      []float64        `protobuf:"fixed64,7,rep,packed,name=value_double" json:"value_double,omitempty"`
	ValueBool        []bool           `protobuf:"varint,8,rep,packed,name=value_bool" json:"value_bool,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}

const Default_Field_ValueType Field_ValueType = Field_STRING

func (m *Field) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Field) GetValueType() Field_ValueType {
	if m != nil && m.ValueType != nil {
		return *m.ValueType
	}
	return Default_Field_ValueType
}

func (m *Field) GetRepresentation() string {
	if m != nil && m.Representation != nil {
		return *m.Representation
	}
	return ""
}

func (m *Field) GetValueString() []string {
	if m != nil {
		return m.ValueString
	}
	return nil
}

func (m *Field) GetValueBytes() [][]byte {
	if m != nil {
		return m.ValueBytes
	}
	return nil
}

func (m *Field) GetValueInteger() []int64 {
	if m != nil {
		return m.ValueInteger
	}
	return nil
}

func (m *Field) GetValueDouble() []float64 {
	if m != nil {
		return m.ValueDouble
	}
	return nil
}

func (m *Field) GetValueBool() []bool {
	if m != nil {
		return m.ValueBool
	}
	return nil
}

type Message struct {
	Uuid             []byte   `protobuf:"bytes,1,req,name=uuid" json:"uuid,omitempty"`
	Timestamp        *int64   `protobuf:"varint,2,req,name=timestamp" json:"timestamp,omitempty"`
	Type             *string  `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Logger           *string  `protobuf:"bytes,4,opt,name=logger" json:"logger,omitempty"`
	Severity         *int32   `protobuf:"varint,5,opt,name=severity,def=7" json:"severity,omitempty"`
	Payload          *string  `protobuf:"bytes,6,opt,name=payload" json:"payload,omitempty"`
	EnvVersion       *string  `protobuf:"bytes,7,opt,name=env_version" json:"env_version,omitempty"`
	Pid              *int32   `protobuf:"varint,8,opt,name=pid" json:"pid,omitempty"`
	Hostname         *string  `protobuf:"bytes,9,opt,name=hostname" json:"hostname,omitempty"`
	Fields           []*Field `protobuf:"bytes,10,rep,name=fields" json:"fields,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}

const Default_Message_Severity int32 = 7

func (m *Message) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Message) GetTimestamp() int64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *Message) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *Message) GetLogger() string {
	if m != nil && m.Logger != nil {
		return *m.Logger
	}
	return ""
}

func (m *Message) GetSeverity() int32 {
	if m != nil && m.Severity != nil {
		return *m.Severity
	}
	return Default_Message_Severity
}

func (m *Message) GetPayload() string {
	if m != nil && m.Payload != nil {
		return *m.Payload
	}
	return ""
}

func (m *Message) GetEnvVersion() string {
	if m != nil && m.EnvVersion != nil {
		return *m.EnvVersion
	}
	return ""
}

func (m *Message) GetPid() int32 {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return 0
}

func (m *Message) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Message) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

func init() {
	proto.RegisterEnum("message.Header_HmacHashFunction", Header_HmacHashFunction_name, Header_HmacHashFunction_value)
	proto.RegisterEnum("message.Field_ValueType", Field_ValueType_name, Field_ValueType_value)
}
func (m *Header) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Header) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageLength != nil {
		data[i] = 0x8
		i++
		i = encodeVarintMessage(data, i, uint64(*m.MessageLength))
	}
	if m.HmacHashFunction != nil {
		data[i] = 0x18
		i++
		i = encodeVarintMessage(data, i, uint64(*m.HmacHashFunction))
	}
	if m.HmacSigner != nil {
		data[i] = 0x22
		i++
		i = encodeVarintMessage(data, i, uint64(len(*m.HmacSigner)))
		i += copy(data[i:], *m.HmacSigner)
	}
	if m.HmacKeyVersion != nil {
		data[i] = 0x28
		i++
		i = encodeVarintMessage(data, i, uint64(*m.HmacKeyVersion))
	}
	if m.Hmac != nil {
		data[i] = 0x32
		i++
		i = encodeVarintMessage(data, i, uint64(len(m.Hmac)))
		i += copy(data[i:], m.Hmac)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Field) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Field) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintMessage(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if m.ValueType != nil {
		data[i] = 0x10
		i++
		i = encodeVarintMessage(data, i, uint64(*m.ValueType))
	}
	if m.Representation != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintMessage(data, i, uint64(len(*m.Representation)))
		i += copy(data[i:], *m.Representation)
	}
	if len(m.ValueString) > 0 {
		for _, s := range m.ValueString {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ValueBytes) > 0 {
		for _, b := range m.ValueBytes {
			data[i] = 0x2a
			i++
			i = encodeVarintMessage(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.ValueInteger) > 0 {
		data2 := make([]byte, len(m.ValueInteger)*10)
		var j1 int
		for _, num1 := range m.ValueInteger {
			num := uint64(num1)
			for num >= 1<<7 {
				data2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			data2[j1] = uint8(num)
			j1++
		}
		data[i] = 0x32
		i++
		i = encodeVarintMessage(data, i, uint64(j1))
		i += copy(data[i:], data2[:j1])
	}
	if len(m.ValueDouble) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintMessage(data, i, uint64(len(m.ValueDouble)*8))
		for _, num := range m.ValueDouble {
			f3 := math1.Float64bits(num)
			data[i] = uint8(f3)
			i++
			data[i] = uint8(f3 >> 8)
			i++
			data[i] = uint8(f3 >> 16)
			i++
			data[i] = uint8(f3 >> 24)
			i++
			data[i] = uint8(f3 >> 32)
			i++
			data[i] = uint8(f3 >> 40)
			i++
			data[i] = uint8(f3 >> 48)
			i++
			data[i] = uint8(f3 >> 56)
			i++
		}
	}
	if len(m.ValueBool) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintMessage(data, i, uint64(len(m.ValueBool)))
		for _, b := range m.ValueBool {
			if b {
				data[i] = 1
			} else {
				data[i] = 0
			}
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Message) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uuid != nil {
		data[i] = 0xa
		i++
		i = encodeVarintMessage(data, i, uint64(len(m.Uuid)))
		i += copy(data[i:], m.Uuid)
	}
	if m.Timestamp != nil {
		data[i] = 0x10
		i++
		i = encodeVarintMessage(data, i, uint64(*m.Timestamp))
	}
	if m.Type != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintMessage(data, i, uint64(len(*m.Type)))
		i += copy(data[i:], *m.Type)
	}
	if m.Logger != nil {
		data[i] = 0x22
		i++
		i = encodeVarintMessage(data, i, uint64(len(*m.Logger)))
		i += copy(data[i:], *m.Logger)
	}
	if m.Severity != nil {
		data[i] = 0x28
		i++
		i = encodeVarintMessage(data, i, uint64(uint32(*m.Severity)))
	}
	if m.Payload != nil {
		data[i] = 0x32
		i++
		i = encodeVarintMessage(data, i, uint64(len(*m.Payload)))
		i += copy(data[i:], *m.Payload)
	}
	if m.EnvVersion != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintMessage(data, i, uint64(len(*m.EnvVersion)))
		i += copy(data[i:], *m.EnvVersion)
	}
	if m.Pid != nil {
		data[i] = 0x40
		i++
		i = encodeVarintMessage(data, i, uint64(uint32(*m.Pid)))
	}
	if m.Hostname != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintMessage(data, i, uint64(len(*m.Hostname)))
		i += copy(data[i:], *m.Hostname)
	}
	if len(m.Fields) > 0 {
		for _, msg := range m.Fields {
			data[i] = 0x52
			i++
			i = encodeVarintMessage(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Message(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Message(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMessage(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Header) Size() (n int) {
	var l int
	_ = l
	if m.MessageLength != nil {
		n += 1 + sovMessage(uint64(*m.MessageLength))
	}
	if m.HmacHashFunction != nil {
		n += 1 + sovMessage(uint64(*m.HmacHashFunction))
	}
	if m.HmacSigner != nil {
		l = len(*m.HmacSigner)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.HmacKeyVersion != nil {
		n += 1 + sovMessage(uint64(*m.HmacKeyVersion))
	}
	if m.Hmac != nil {
		l = len(m.Hmac)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.ValueType != nil {
		n += 1 + sovMessage(uint64(*m.ValueType))
	}
	if m.Representation != nil {
		l = len(*m.Representation)
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.ValueString) > 0 {
		for _, s := range m.ValueString {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.ValueBytes) > 0 {
		for _, b := range m.ValueBytes {
			l = len(b)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.ValueInteger) > 0 {
		l = 0
		for _, e := range m.ValueInteger {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if len(m.ValueDouble) > 0 {
		n += 1 + sovMessage(uint64(len(m.ValueDouble)*8)) + len(m.ValueDouble)*8
	}
	if len(m.ValueBool) > 0 {
		n += 1 + sovMessage(uint64(len(m.ValueBool))) + len(m.ValueBool)*1
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.Uuid != nil {
		l = len(m.Uuid)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Timestamp != nil {
		n += 1 + sovMessage(uint64(*m.Timestamp))
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Logger != nil {
		l = len(*m.Logger)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Severity != nil {
		n += 1 + sovMessage(uint64(uint32(*m.Severity)))
	}
	if m.Payload != nil {
		l = len(*m.Payload)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.EnvVersion != nil {
		l = len(*m.EnvVersion)
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Pid != nil {
		n += 1 + sovMessage(uint64(uint32(*m.Pid)))
	}
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMessage(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Header) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageLength", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MessageLength = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HmacHashFunction", wireType)
			}
			var v Header_HmacHashFunction
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (Header_HmacHashFunction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HmacHashFunction = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HmacSigner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.HmacSigner = &s
			index = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HmacKeyVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HmacKeyVersion = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hmac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hmac = append([]byte{}, data[index:postIndex]...)
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *Field) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Name = &s
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			var v Field_ValueType
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (Field_ValueType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValueType = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Representation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Representation = &s
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueString = append(m.ValueString, string(data[index:postIndex]))
			index = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBytes = append(m.ValueBytes, make([]byte, postIndex-index))
			copy(m.ValueBytes[len(m.ValueBytes)-1], data[index:postIndex])
			index = postIndex
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if index >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[index]
					index++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := index + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for index < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if index >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[index]
						index++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ValueInteger = append(m.ValueInteger, v)
				}
			} else if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if index >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[index]
					index++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ValueInteger = append(m.ValueInteger, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueInteger", wireType)
			}
		case 7:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if index >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[index]
					index++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := index + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for index < postIndex {
					var v uint64
					i := index + 8
					if i > l {
						return io.ErrUnexpectedEOF
					}
					index = i
					v = uint64(data[i-8])
					v |= uint64(data[i-7]) << 8
					v |= uint64(data[i-6]) << 16
					v |= uint64(data[i-5]) << 24
					v |= uint64(data[i-4]) << 32
					v |= uint64(data[i-3]) << 40
					v |= uint64(data[i-2]) << 48
					v |= uint64(data[i-1]) << 56
					v2 := math2.Float64frombits(v)
					m.ValueDouble = append(m.ValueDouble, v2)
				}
			} else if wireType == 1 {
				var v uint64
				i := index + 8
				if i > l {
					return io.ErrUnexpectedEOF
				}
				index = i
				v = uint64(data[i-8])
				v |= uint64(data[i-7]) << 8
				v |= uint64(data[i-6]) << 16
				v |= uint64(data[i-5]) << 24
				v |= uint64(data[i-4]) << 32
				v |= uint64(data[i-3]) << 40
				v |= uint64(data[i-2]) << 48
				v |= uint64(data[i-1]) << 56
				v2 := math2.Float64frombits(v)
				m.ValueDouble = append(m.ValueDouble, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueDouble", wireType)
			}
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if index >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[index]
					index++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := index + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for index < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if index >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[index]
						index++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ValueBool = append(m.ValueBool, bool(v != 0))
				}
			} else if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if index >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[index]
					index++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ValueBool = append(m.ValueBool, bool(v != 0))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBool", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *Message) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append([]byte{}, data[index:postIndex]...)
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamp = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Type = &s
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Logger = &s
			index = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Severity = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Payload = &s
			index = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.EnvVersion = &s
			index = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pid = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Hostname = &s
			index = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &Field{})
			m.Fields[len(m.Fields)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
